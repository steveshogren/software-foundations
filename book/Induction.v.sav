(*HIDE*)Cg==
(*UHIDE*)

(** * Induction: Proof by Induction *)

(** First, we import all of our definitions from the previous
    chapter. *)

Require Export chap1.

(** For the [Require Export] to work, you first need to use
    [coqc] to compile [Basics.v] into [Basics.vo].  This is like
    making a .class file from a .java file, or a .o file from a .c
    file.  There are two ways to do it:

     - In CoqIDE:

         Open [Basics.v].  In the "Compile" menu, click on "Compile
         Buffer".

     - From the command line:

         Run [coqc Basics.v]

    *)

(* ################################################################# *)
(** * Proof by Induction *)

(** We proved in the last chapter that [0] is a neutral element
    for [+] on the left using an easy argument based on
    simplification.  The fact that it is also a neutral element on the
    _right_... *)

Theorem plus_n_O_firsttry : forall n:nat,
  n = n + 0.

(** ... cannot be proved in the same simple way.  Just applying
  [reflexivity] doesn't work, since the [n] in [n + 0] is an arbitrary
  unknown number, so the [match] in the definition of [+] can't be
  simplified.  *)

Proof.
  intros n.
  simpl. 
Abort.

(** And reasoning by cases using [destruct n] doesn't get us much
   further: the branch of the case analysis where we assume [n = 0]
   goes through fine, but in the branch where [n = S n'] for some [n'] we
   get stuck in exactly the same way.  We could use [destruct n'] to
   get one step further, but, since [n] can be arbitrarily large, if we
   try to keep on like this we'll never be done. *)


Theorem plus_n_O_secondtry : forall n:nat,
  n = n + 0.
Proof.
  intros n. destruct n as [| n'].
  - (* n = 0 *)
    reflexivity. (* so far so good... *)
  - (* n = S n' *)
    simpl.       (* ...but here we are stuck again *)
Abort.

(** To prove interesting facts about numbers, lists, and other
    inductively defined sets, we usually need a more powerful
    reasoning principle: _induction_.

    Recall (from high school, a discrete math course, etc.) the
    principle of induction over natural numbers: If [P(n)] is some
    proposition involving a natural number [n] and we want to show
    that [P] holds for _all_ numbers [n], we can reason like this:
         - show that [P(O)] holds;
         - show that, for any [n'], if [P(n')] holds, then so does
           [P(S n')];
         - conclude that [P(n)] holds for all [n].

    In Coq, the steps are the same but the order is backwards: we
    begin with the goal of proving [P(n)] for all [n] and break it
    down (by applying the [induction] tactic) into two separate
    subgoals: first showing [P(O)] and then showing [P(n') -> P(S
    n')].  Here's how this works for the theorem at hand: *)

Theorem plus_n_O : forall n:nat, n = n + 0.
Proof.
  intros n. induction n as [| n' IHn'].
  - (* n = 0 *)    reflexivity.
  - (* n = S n' *) simpl. rewrite <- IHn'. reflexivity.  Qed.

(** Like [destruct], the [induction] tactic takes an [as...]
    clause that specifies the names of the variables to be introduced
    in the subgoals.  In the first branch, [n] is replaced by [0] and
    the goal becomes [0 + 0 = 0], which follows by simplification.  In
    the second, [n] is replaced by [S n'] and the assumption [n' + 0 =
    n'] is added to the context (with the name [IHn'], i.e., the
    Induction Hypothesis for [n'] -- notice that this name is
    explicitly chosen in the [as...] clause of the call to [induction]
    rather than letting Coq choose one arbitrarily). The goal in this
    case becomes [(S n') + 0 = S n'], which simplifies to [S (n' + 0)
    = S n'], which in turn follows from [IHn']. *)

(* We cannot use destruct here, because it is not forall n, just for that
specific n. After the O case, we are left with the n case, which is exactly what
we are trying to prove! *)
Theorem plus_n_Od : forall n:nat, n = n + 0.
Proof.
  intros n. destruct n.
  - (* n = 0 *)    reflexivity.
  - (* S n = S (n + 0) *) simpl. Admitted.

(* So induction differs in that it works forall n, not just n. It also creates a
hypothesis we can use for our matching. I am still very confused on the concept
of how using the thing we are proving to prove our Theorem makes any sense at
all... :/ *)

Theorem minus_diag : forall n,
  minus n n = 0.
Proof.
  (* WORKED IN CLASS *)
  intros n. induction n as [| n' IHn'].
  - (* n = 0 *)
    simpl. reflexivity.
  - (* n = S n' *)
    simpl. rewrite -> IHn'. reflexivity.  Qed.

(** (The use of the [intros] tactic in these proofs is actually
    redundant.  When applied to a goal that contains quantified
    variables, the [induction] tactic will automatically move them
    into the context as needed.) *)

(** **** Exercise: 2 stars, recommended (basic_induction)  *)
(** Prove the following using induction. You might need previously
    proven results. *)
(* Its becoming more and more apparent that proofs must be built up out of
smaller proofs. A good first step would be to consider what proofs I have
already proven. This book seems to link exercises and examples together: the
solution for a proof is highly likely to be found in the prior proofs. *)

(*HIDE*)CgpUaGVvcmVtIG11bHRfMF9yIDogZm9yYWxsIG46bmF0LAogIG4gKiAwID0gMC4KUHJvb2YuCiAg
aW50cm9zIG4uIGluZHVjdGlvbiBuIGFzIFt8IG4nIElIbiddLgogICAgc2ltcGwuIHJlZmxleGl2
aXR5LgogICAgc2ltcGwuIHJld3JpdGUgLT4gSUhuJy4gcmVmbGV4aXZpdHkuClFlZC4KClRoZW9y
ZW0gYWRkX2VxdWl2IDogZm9yYWxsIG46bmF0LAogIFMobikgPSBTKG4pLgpQcm9vZi4KICBpbnRy
b3Mgbi4gaW5kdWN0aW9uIG4gYXMgW3wgbicgSUhuJ10uCiAgICBzaW1wbC4gcmVmbGV4aXZpdHku
CiAgICBzaW1wbC4gcmVmbGV4aXZpdHkuClFlZC4KCigqIFNldCBQcmludGluZyBBbGwuICopClRo
ZW9yZW0gcGx1c19uX1NtIDogZm9yYWxsIG4gbSA6IG5hdCwgCiAgUyAobiArIG0pID0gbiArIChT
IG0pLgpQcm9vZi4KICAoKiB3aXRob3V0IGludHJvZHVjaW5nIG4gQU5OTk5ORCBtIGhlcmUsIHRo
ZSByZXdyaXRlIGRvZXNuJ3QgbWF0Y2guIGdycnJyICopCiAgaW50cm9zIG4gbS4gaW5kdWN0aW9u
IG4gYXMgW3wgbicgSUhuJ10uCiAgLSB7IHNpbXBsLiByZWZsZXhpdml0eS4gfQogIC0geyBzaW1w
bC4gcmV3cml0ZSA8LSBJSG4nLiByZWZsZXhpdml0eS4gfQpRZWQuIAoKVGhlb3JlbSBwbHVzX2Nv
bW0gOiBmb3JhbGwgbiBtIDogbmF0LAogIG4gKyBtID0gbSArIG4uClByb29mLgogIGludHJvcyBu
IG0uIGluZHVjdGlvbiBuIGFzIFt8IG4nIElIbiddOyBzaW1wbC4KICAoKiBJIGhhdmUgdG8gcmVt
ZW1iZXIgdG8gdXNlIGV4aXN0aW5nIHByb29mcyEgKikKICByZXdyaXRlIDwtIHBsdXNfbl9PLiBy
ZWZsZXhpdml0eS4KICByZXdyaXRlIDwtIHBsdXNfbl9TbS4gcmV3cml0ZSAtPiBJSG4nLiByZWZs
ZXhpdml0eS4KUWVkLgoKVGhlb3JlbSBwbHVzX2Fzc29jIDogZm9yYWxsIG4gbSBwIDogbmF0LAog
IG4gKyAobSArIHApID0gKG4gKyBtKSArIHAuClByb29mLgogIGludHJvcyBuIG0gcC4gaW5kdWN0
aW9uIG4gYXMgW3wgbicgSUhuJ107IHNpbXBsLgogIHJlZmxleGl2aXR5LgogIHJld3JpdGUgPC0g
SUhuJy4gc2ltcGwuIHJlZmxleGl2aXR5LgpRZWQuCigqKiBbXSAqKQoKCigqKiAqKioqIEV4ZXJj
aXNlOiAyIHN0YXJzIChkb3VibGVfcGx1cykgICopCigqKiBDb25zaWRlciB0aGUgZm9sbG93aW5n
IGZ1bmN0aW9uLCB3aGljaCBkb3VibGVzIGl0cyBhcmd1bWVudDogKikKCkZpeHBvaW50IGRvdWJs
ZSAobjpuYXQpIDo9CiAgbWF0Y2ggbiB3aXRoCiAgfCBPID0+IE8KICB8IFMgbicgPT4gUyAoUyAo
ZG91YmxlIG4nKSkKICBlbmQuCgooKiogVXNlIGluZHVjdGlvbiB0byBwcm92ZSB0aGlzIHNpbXBs
ZSBmYWN0IGFib3V0IFtkb3VibGVdOiAqKQoKTGVtbWEgZG91YmxlX3BsdXMgOiBmb3JhbGwgbiwg
ZG91YmxlIG4gPSBuICsgbiAuClByb29mLgogIGludHJvcyBuLiBpbmR1Y3Rpb24gbiBhcyBbfCBu
JyBJSG4nXS4KICByZWZsZXhpdml0eS4KICBzaW1wbC4gcmV3cml0ZSA8LSBwbHVzX25fU20uIHJl
d3JpdGUgPC0gSUhuJy4gcmVmbGV4aXZpdHkuClFlZC4KKCoqIFtdICopCgooKiogKioqKiBFeGVy
Y2lzZTogMiBzdGFycywgb3B0aW9uYWwgKGV2ZW5iX1MpICAqKQooKiogT25lIGluY29udmVuaW5l
bnQgYXNwZWN0IG9mIG91ciBkZWZpbml0aW9uIG9mIFtldmVuYiBuXSBpcyB0aGF0IGl0CiAgICBt
YXkgbmVlZCB0byBwZXJmb3JtIGEgcmVjdXJzaXZlIGNhbGwgb24gW24gLSAyXS4gVGhpcyBtYWtl
cyBwcm9vZnMKICAgIGFib3V0IFtldmVuYiBuXSBoYXJkZXIgd2hlbiBkb25lIGJ5IGluZHVjdGlv
biBvbiBbbl0sIHNpbmNlIHdlIG1heQogICAgbmVlZCBhbiBpbmR1Y3Rpb24gaHlwb3RoZXNpcyBh
Ym91dCBbbiAtIDJdLiBUaGUgZm9sbG93aW5nIGxlbW1hCiAgICBnaXZlcyBhIGJldHRlciBjaGFy
YWN0ZXJpemF0aW9uIG9mIFtldmVuYiAoUyBuKV06ICopCgpUaGVvcmVtIG5lZ2JfZG91YmxlZCA6
IGZvcmFsbCBiIDogYm9vbCwgbmVnYiAobmVnYiBiKSA9IGIuClByb29mLgogIGludHJvcyBiLiBp
bmR1Y3Rpb24gYjsgcmVmbGV4aXZpdHkuClFlZC4KClRoZW9yZW0gZXZlbmJfUyA6IGZvcmFsbCBu
IDogbmF0LAogIGV2ZW5iIChTIG4pID0gbmVnYiAoZXZlbmIgbikuClByb29mLgogIGludHJvcyBu
LiBpbmR1Y3Rpb24gbiBhcyBbfCBuJyBJSG4nXS4KICByZWZsZXhpdml0eS4KICBpbmR1Y3Rpb24g
bicuCiAgLSB7IHNpbXBsLiByZWZsZXhpdml0eS4gfQogIC0geyByZXdyaXRlIC0+IElIbicuCiAg
ICAgIHJld3JpdGUgLT4gbmVnYl9kb3VibGVkLgogICAgICByZWZsZXhpdml0eS4gfQpRZWQuCigq
KiBbXSAqKQoKKCoqICoqKiogRXhlcmNpc2U6IDEgc3RhciAoZGVzdHJ1Y3RfaW5kdWN0aW9uKSAg
KikKKCoqIEJyaWVmbHkgZXhwbGFpbiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSB0YWN0aWNz
IFtkZXN0cnVjdF0gCiAgICBhbmQgW2luZHVjdGlvbl0uCgooKiBGSUxMIElOIEhFUkUgKikKKikK
KCoqIFtdICopCgo=
(*UHIDE*)

(* ################################################################# *)
(** * Proofs Within Proofs *)

(** In Coq, as in informal mathematics, large proofs are often
    broken into a sequence of theorems, with later proofs referring to
    earlier theorems.  But sometimes a proof will require some
    miscellaneous fact that is too trivial and of too little general
    interest to bother giving it its own top-level name.  In such
    cases, it is convenient to be able to simply state and prove the
    needed "sub-theorem" right at the point where it is used.  The
    [assert] tactic allows us to do this.  For example, our earlier
    proof of the [mult_0_plus] theorem referred to a previous theorem
    named [plus_O_n].  We could instead use [assert] to state and
    prove [plus_O_n] in-line: *)

Theorem mult_0_plus' : forall n m : nat,
  (0 + n) * m = n * m.
Proof.
  intros n m.
  assert (H: 0 + n = n). { reflexivity. }
  rewrite -> H.
  reflexivity.  Qed.

(** The [assert] tactic introduces two sub-goals.  The first is
    the assertion itself; by prefixing it with [H:] we name the
    assertion [H].  (We can also name the assertion with [as] just as
    we did above with [destruct] and [induction], i.e., [assert (0 + n
    = n) as H].)  Note that we surround the proof of this assertion
    with curly braces [{ ... }], both for readability and so that,
    when using Coq interactively, we can see more easily when we have
    finished this sub-proof.  The second goal is the same as the one
    at the point where we invoke [assert] except that, in the context,
    we now have the assumption [H] that [0 + n = n].  That is,
    [assert] generates one subgoal where we must prove the asserted
    fact and a second subgoal where we can use the asserted fact to
    make progress on whatever we were trying to prove in the first
    place. *)

(** The [assert] tactic is handy in many sorts of situations.  For
    example, suppose we want to prove that [(n + m) + (p + q) = (m +
    n) + (p + q)]. The only difference between the two sides of the
    [=] is that the arguments [m] and [n] to the first inner [+] are
    swapped, so it seems we should be able to use the commutativity of
    addition ([plus_comm]) to rewrite one into the other.  However,
    the [rewrite] tactic is a little stupid about _where_ it applies
    the rewrite.  There are three uses of [+] here, and it turns out
    that doing [rewrite -> plus_comm] will affect only the _outer_
    one... *)

Theorem plus_rearrange_firsttry : forall n m p q : nat,
  (n + m) + (p + q) = (m + n) + (p + q).
Proof.
  intros n m p q.
  (* We just need to swap (n + m) for (m + n)...
     it seems like plus_comm should do the trick! *)
  rewrite -> plus_comm.
  (* Doesn't work...Coq rewrote the wrong plus! *)
Abort.

(** To get [plus_comm] to apply at the point where we want it to, we
    can introduce a local lemma stating that [n + m = m + n] (for the
    particular [m] and [n] that we are talking about here), prove this
    lemma using [plus_comm], and then use it to do the desired
    rewrite. *)

Theorem plus_rearrange : forall n m p q : nat,
  (n + m) + (p + q) = (m + n) + (p + q).
Proof.
  intros n m p q.
  assert (H: n + m = m + n).
  { rewrite -> plus_comm. reflexivity. }
  rewrite -> H. reflexivity.  Qed.

(* ################################################################# *)
(*HIDE*)CigqKiAqIE1vcmUgRXhlcmNpc2VzICopCgooKiogKioqKiBFeGVyY2lzZTogMyBzdGFycywgcmVj
b21tZW5kZWQgKG11bHRfY29tbSkgICopCigqKiBVc2UgW2Fzc2VydF0gdG8gaGVscCBwcm92ZSB0
aGlzIHRoZW9yZW0uICBZb3Ugc2hvdWxkbid0IG5lZWQgdG8KICAgIHVzZSBpbmR1Y3Rpb24gb24g
W3BsdXNfc3dhcF0uICopCgooKiBUaGVvcmVtIHBsdXNfYXNzb2MgOiBmb3JhbGwgbiBtIHAgOiBu
YXQsICopCigqICAgbiArIChtICsgcCkgPSAobiArIG0pICsgcC4gKikKCigqIFRoZW9yZW0gcGx1
c19jb21tIDogZm9yYWxsIG4gbSA6IG5hdCwgKikKKCogICBuICsgbSA9IG0gKyBuLiAqKQoKVGhl
b3JlbSBwbHVzX3N3YXAgOiBmb3JhbGwgbiBtIHAgOiBuYXQsCiAgbiArIChtICsgcCkgPSBtICsg
KG4gKyBwKS4KUHJvb2YuCiAgaW50cm9zIG4gbSBwLgogIHJld3JpdGUgLT4gcGx1c19jb21tLgog
IHJld3JpdGUgPC0gcGx1c19hc3NvYy4KICBhc3NlcnQgKEg6IHAgKyBuID0gbiArIHApLgogIHsg
cmV3cml0ZSAtPiBwbHVzX2NvbW0uIHJlZmxleGl2aXR5LiB9CiAgcmV3cml0ZSAtPiBILiAgCiAg
cmVmbGV4aXZpdHkuClFlZC4KCigqKiBOb3cgcHJvdmUgY29tbXV0YXRpdml0eSBvZiBtdWx0aXBs
aWNhdGlvbi4gIChZb3Ugd2lsbCBwcm9iYWJseQogICAgbmVlZCB0byBkZWZpbmUgYW5kIHByb3Zl
IGEgc2VwYXJhdGUgc3Vic2lkaWFyeSB0aGVvcmVtIHRvIGJlIHVzZWQKICAgIGluIHRoZSBwcm9v
ZiBvZiB0aGlzIG9uZS4gIFlvdSBtYXkgZmluZCB0aGF0IFtwbHVzX3N3YXBdIGNvbWVzIGluCiAg
ICBoYW5keS4pICopCgpUaGVvcmVtIG11bHRfMV9uIDogZm9yYWxsIG4sIG4gKiAxID0gbi4KUHJv
b2YuCiAgaW50cm9zIG4uCiAgaW5kdWN0aW9uIG4gYXMgW3wgbiddOyBzaW1wbC4KICByZWZsZXhp
dml0eS4KICByZXdyaXRlIC0+IElIbicuIHJlZmxleGl2aXR5LgpRZWQuCgpUaGVvcmVtIG11bHRf
Y29tbV9sZW1tYSA6IGZvcmFsbCBuIG0sIG0gKiBTIG4gPSBtICsgbSAqIG4uClByb29mLgogIGlu
dHJvcyBuIG0uCiAgaW5kdWN0aW9uIG0gYXMgW3wgcF0gOyBzaW1wbC4KICB7IHJlZmxleGl2aXR5
LiB9CiAgeyByZXdyaXRlIC0+IHBsdXNfc3dhcC4gcmV3cml0ZSAtPiBJSHAuIHJlZmxleGl2aXR5
LiB9ClFlZC4KClRoZW9yZW0gbXVsdF9jb21tIDogZm9yYWxsIG0gbiA6IG5hdCwKICBtICogbiA9
IG4gKiBtLgpQcm9vZi4KICBpbnRyb3MgbSBuLgogIGluZHVjdGlvbiBuIGFzIFt8IG4nIF07IHNp
bXBsLgogIHJld3JpdGUgLT4gbXVsdF8wX3IuIHJlZmxleGl2aXR5LgogIHJld3JpdGUgLT4gbXVs
dF9jb21tX2xlbW1hLiByZXdyaXRlIC0+IElIbicuIHJlZmxleGl2aXR5LgpRZWQuCigqKiBbXSAq
KQoKKCoqICoqKiogRXhlcmNpc2U6IDMgc3RhcnMsIG9wdGlvbmFsIChtb3JlX2V4ZXJjaXNlcykg
ICopCigqKiBUYWtlIGEgcGllY2Ugb2YgcGFwZXIuICBGb3IgZWFjaCBvZiB0aGUgZm9sbG93aW5n
IHRoZW9yZW1zLCBmaXJzdAogICAgX3RoaW5rXyBhYm91dCB3aGV0aGVyIChhKSBpdCBjYW4gYmUg
cHJvdmVkIHVzaW5nIG9ubHkKICAgIHNpbXBsaWZpY2F0aW9uIGFuZCByZXdyaXRpbmcsIChiKSBp
dCBhbHNvIHJlcXVpcmVzIGNhc2UKICAgIGFuYWx5c2lzIChbZGVzdHJ1Y3RdKSwgb3IgKGMpIGl0
IGFsc28gcmVxdWlyZXMgaW5kdWN0aW9uLiAgV3JpdGUKICAgIGRvd24geW91ciBwcmVkaWN0aW9u
LiAgVGhlbiBmaWxsIGluIHRoZSBwcm9vZi4gIChUaGVyZSBpcyBubyBuZWVkCiAgICB0byB0dXJu
IGluIHlvdXIgcGllY2Ugb2YgcGFwZXI7IHRoaXMgaXMganVzdCB0byBlbmNvdXJhZ2UgeW91IHRv
CiAgICByZWZsZWN0IGJlZm9yZSB5b3UgaGFjayEpICopCgpUaGVvcmVtIGxlYl9yZWZsIDogZm9y
YWxsIG46bmF0LAogIHRydWUgPSBsZWIgbiBuLgpQcm9vZi4KICBpbnRyb3Mgbi4KICBpbmR1Y3Rp
b24gbiBhcyBbfCBuJ10uCiAgcmVmbGV4aXZpdHkuCiAgc2ltcGwuIHJld3JpdGUgLT4gSUhuJy4g
cmVmbGV4aXZpdHkuClFlZC4KClRoZW9yZW0gemVyb19uYmVxX1MgOiBmb3JhbGwgbjpuYXQsCiAg
YmVxX25hdCAwIChTIG4pID0gZmFsc2UuClByb29mLgogIGludHJvcyBuLiByZWZsZXhpdml0eS4K
UWVkLgoKVGhlb3JlbSBhbmRiX2ZhbHNlX3IgOiBmb3JhbGwgYiA6IGJvb2wsCiAgYW5kYiBiIGZh
bHNlID0gZmFsc2UuClByb29mLgogIGRlc3RydWN0IGI7IHJlZmxleGl2aXR5LgpRZWQuCgpUaGVv
cmVtIHBsdXNfYmxlX2NvbXBhdF9sIDogZm9yYWxsIG4gbSBwIDogbmF0LAogIGxlYiBuIG0gPSB0
cnVlIC0+IGxlYiAocCArIG4pIChwICsgbSkgPSB0cnVlLgpQcm9vZi4KICBpbnRyb3MgbiBtIHAg
SC4KICBpbmR1Y3Rpb24gcCBhcyBbfCBwJyBdIDsgc2ltcGwuCiAgLSB7IHJld3JpdGUgPC0gSC4g
cmVmbGV4aXZpdHkuIH0KICAtIHsgcmV3cml0ZSAtPiBJSHAnLiByZWZsZXhpdml0eS4gfQpRZWQu
CgpUaGVvcmVtIFNfbmJlcV8wIDogZm9yYWxsIG46bmF0LAogIGJlcV9uYXQgKFMgbikgMCA9IGZh
bHNlLgpQcm9vZi4KICBpbnRyb3Mgbi4KICBzaW1wbC4KICByZWZsZXhpdml0eS4KUWVkLgoKVGhl
b3JlbSBtdWx0XzFfbCA6IGZvcmFsbCBuOm5hdCwKICAgIDEgKiBuID0gbi4KUHJvb2YuCiAgaW50
cm9zIG4uCiAgc2ltcGwuCiAgcmV3cml0ZSAtPiBwbHVzX25fTy4KICByZWZsZXhpdml0eS4KUWVk
LgoKVGhlb3JlbSBhbGwzX3NwZWMgOiBmb3JhbGwgYiBjIDogYm9vbCwKICAgIG9yYgogICAgICAo
YW5kYiBiIGMpCiAgICAgIChvcmIgKG5lZ2IgYikKICAgICAgICAgICAgICAgKG5lZ2IgYykpCiAg
PSB0cnVlLgpQcm9vZi4KICAoKiBGSUxMIElOIEhFUkUgKikgQWRtaXR0ZWQuCgpUaGVvcmVtIG11
bHRfcGx1c19kaXN0cl9yIDogZm9yYWxsIG4gbSBwIDogbmF0LAogIChuICsgbSkgKiBwID0gKG4g
KiBwKSArIChtICogcCkuClByb29mLgogICgqIEZJTEwgSU4gSEVSRSAqKSBBZG1pdHRlZC4KClRo
ZW9yZW0gbXVsdF9hc3NvYyA6IGZvcmFsbCBuIG0gcCA6IG5hdCwKICBuICogKG0gKiBwKSA9IChu
ICogbSkgKiBwLgpQcm9vZi4KICAoKiBGSUxMIElOIEhFUkUgKikgQWRtaXR0ZWQuCigqKiBbXSAq
KQoKKCoqICoqKiogRXhlcmNpc2U6IDIgc3RhcnMsIG9wdGlvbmFsIChiZXFfbmF0X3JlZmwpICAq
KQooKiogUHJvdmUgdGhlIGZvbGxvd2luZyB0aGVvcmVtLiAgKFB1dHRpbmcgdGhlIFt0cnVlXSBv
biB0aGUgbGVmdC1oYW5kCiAgICBzaWRlIG9mIHRoZSBlcXVhbGl0eSBtYXkgbG9vayBvZGQsIGJ1
dCB0aGlzIGlzIGhvdyB0aGUgdGhlb3JlbSBpcwogICAgc3RhdGVkIGluIHRoZSBDb3Egc3RhbmRh
cmQgbGlicmFyeSwgc28gd2UgZm9sbG93IHN1aXQuICBSZXdyaXRpbmcKICAgIHdvcmtzIGVxdWFs
bHkgd2VsbCBpbiBlaXRoZXIgZGlyZWN0aW9uLCBzbyB3ZSB3aWxsIGhhdmUgbm8gcHJvYmxlbQog
ICAgdXNpbmcgdGhlIHRoZW9yZW0gbm8gbWF0dGVyIHdoaWNoIHdheSB3ZSBzdGF0ZSBpdC4pICop
CgpUaGVvcmVtIGJlcV9uYXRfcmVmbCA6IGZvcmFsbCBuIDogbmF0LAogIHRydWUgPSBiZXFfbmF0
IG4gbi4KUHJvb2YuCiAgKCogRklMTCBJTiBIRVJFICopIEFkbWl0dGVkLgooKiogW10gKikKCigq
KiAqKioqIEV4ZXJjaXNlOiAyIHN0YXJzLCBvcHRpb25hbCAocGx1c19zd2FwJykgICopCigqKiBU
aGUgW3JlcGxhY2VdIHRhY3RpYyBhbGxvd3MgeW91IHRvIHNwZWNpZnkgYSBwYXJ0aWN1bGFyIHN1
YnRlcm0gdG8KICAgcmV3cml0ZSBhbmQgd2hhdCB5b3Ugd2FudCBpdCByZXdyaXR0ZW4gdG86IFty
ZXBsYWNlICh0KSB3aXRoICh1KV0KICAgcmVwbGFjZXMgKGFsbCBjb3BpZXMgb2YpIGV4cHJlc3Np
b24gW3RdIGluIHRoZSBnb2FsIGJ5IGV4cHJlc3Npb24KICAgW3VdLCBhbmQgZ2VuZXJhdGVzIFt0
ID0gdV0gYXMgYW4gYWRkaXRpb25hbCBzdWJnb2FsLiBUaGlzIGlzIG9mdGVuCiAgIHVzZWZ1bCB3
aGVuIGEgcGxhaW4gW3Jld3JpdGVdIGFjdHMgb24gdGhlIHdyb25nIHBhcnQgb2YgdGhlIGdvYWwu
CgogICBVc2UgdGhlIFtyZXBsYWNlXSB0YWN0aWMgdG8gZG8gYSBwcm9vZiBvZiBbcGx1c19zd2Fw
J10sIGp1c3QgbGlrZQogICBbcGx1c19zd2FwXSBidXQgd2l0aG91dCBuZWVkaW5nIFthc3NlcnQg
KG4gKyBtID0gbSArIG4pXS4gKikKClRoZW9yZW0gcGx1c19zd2FwJyA6IGZvcmFsbCBuIG0gcCA6
IG5hdCwKICBuICsgKG0gKyBwKSA9IG0gKyAobiArIHApLgpQcm9vZi4KICAoKiBGSUxMIElOIEhF
UkUgKikgQWRtaXR0ZWQuCigqKiBbXSAqKQoKKCoqICoqKiogRXhlcmNpc2U6IDMgc3RhcnMsIHJl
Y29tbWVuZGVkIChiaW5hcnlfY29tbXV0ZSkgICopCigqKiBSZWNhbGwgdGhlIFtpbmNyXSBhbmQg
W2Jpbl90b19uYXRdIGZ1bmN0aW9ucyB0aGF0IHlvdQogICAgd3JvdGUgZm9yIHRoZSBbYmluYXJ5
XSBleGVyY2lzZSBpbiB0aGUgW0Jhc2ljc10gY2hhcHRlci4gIFByb3ZlCiAgICB0aGF0IHRoZSBm
b2xsb3dpbmcgZGlhZ3JhbSBjb21tdXRlczoKCiAgICAgICAgICAgICAgIGJpbiAtLS0tLS0tLS0g
aW5jciAtLS0tLS0tPiBiaW4KICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAg
ICAgICB8CiAgICAgICAgICAgIGJpbl90b19uYXQgICAgICAgICAgICAgICAgICBiaW5fdG9fbmF0
CiAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfAogICAgICAgICAg
ICAgICAgdiAgICAgICAgICAgICAgICAgICAgICAgICAgIHYKICAgICAgICAgICAgICAgbmF0IC0t
LS0tLS0tLS0gUyAtLS0tLS0tLS0+IG5hdAoKICAgIFRoYXQgaXMsIGluY3JlbWVudGluZyBhIGJp
bmFyeSBudW1iZXIgYW5kIHRoZW4gY29udmVydGluZyBpdCB0byAKICAgIGEgKHVuYXJ5KSBuYXR1
cmFsIG51bWJlciB5aWVsZHMgdGhlIHNhbWUgcmVzdWx0IGFzIGZpcnN0IGNvbnZlcnRpbmcKICAg
IGl0IHRvIGEgbmF0dXJhbCBudW1iZXIgYW5kIHRoZW4gaW5jcmVtZW50aW5nLiAgCiAgICBOYW1l
IHlvdXIgdGhlb3JlbSBbYmluX3RvX25hdF9wcmVzX2luY3JdICgicHJlcyIgZm9yICJwcmVzZXJ2
ZXMiKS4KCiAgICBCZWZvcmUgeW91IHN0YXJ0IHdvcmtpbmcgb24gdGhpcyBleGVyY2lzZSwgcGxl
YXNlIGNvcHkgdGhlCiAgICBkZWZpbml0aW9ucyBmcm9tIHlvdXIgc29sdXRpb24gdG8gdGhlIFti
aW5hcnldIGV4ZXJjaXNlIGhlcmUgc28KICAgIHRoYXQgdGhpcyBmaWxlIGNhbiBiZSBncmFkZWQg
b24gaXRzIG93bi4gIElmIHlvdSBmaW5kIHlvdXJzZWxmCiAgICB3YW50aW5nIHRvIGNoYW5nZSB5
b3VyIG9yaWdpbmFsIGRlZmluaXRpb25zIHRvIG1ha2UgdGhlIHByb3BlcnR5CiAgICBlYXNpZXIg
dG8gcHJvdmUsIGZlZWwgZnJlZSB0byBkbyBzbyEgKikKCigqIEZJTEwgSU4gSEVSRSAqKQooKiog
W10gKikKCigqKiAqKioqIEV4ZXJjaXNlOiA1IHN0YXJzLCBhZHZhbmNlZCAoYmluYXJ5X2ludmVy
c2UpICAqKQooKiogVGhpcyBleGVyY2lzZSBpcyBhIGNvbnRpbnVhdGlvbiBvZiB0aGUgcHJldmlv
dXMgZXhlcmNpc2UgYWJvdXQKICAgIGJpbmFyeSBudW1iZXJzLiAgWW91IHdpbGwgbmVlZCB5b3Vy
IGRlZmluaXRpb25zIGFuZCB0aGVvcmVtcyBmcm9tCiAgICB0aGVyZSB0byBjb21wbGV0ZSB0aGlz
IG9uZS4KCiAgICAoYSkgRmlyc3QsIHdyaXRlIGEgZnVuY3Rpb24gdG8gY29udmVydCBuYXR1cmFs
IG51bWJlcnMgdG8gYmluYXJ5CiAgICAgICAgbnVtYmVycy4gIFRoZW4gcHJvdmUgdGhhdCBzdGFy
dGluZyB3aXRoIGFueSBuYXR1cmFsIG51bWJlciwKICAgICAgICBjb252ZXJ0aW5nIHRvIGJpbmFy
eSwgdGhlbiBjb252ZXJ0aW5nIGJhY2sgeWllbGRzIHRoZSBzYW1lCiAgICAgICAgbmF0dXJhbCBu
dW1iZXIgeW91IHN0YXJ0ZWQgd2l0aC4KCiAgICAoYikgWW91IG1pZ2h0IG5hdHVyYWxseSB0aGlu
ayB0aGF0IHdlIHNob3VsZCBhbHNvIHByb3ZlIHRoZQogICAgICAgIG9wcG9zaXRlIGRpcmVjdGlv
bjogdGhhdCBzdGFydGluZyB3aXRoIGEgYmluYXJ5IG51bWJlciwKICAgICAgICBjb252ZXJ0aW5n
IHRvIGEgbmF0dXJhbCwgYW5kIHRoZW4gYmFjayB0byBiaW5hcnkgeWllbGRzIHRoZQogICAgICAg
IHNhbWUgbnVtYmVyIHdlIHN0YXJ0ZWQgd2l0aC4gIEhvd2V2ZXIsIHRoaXMgaXMgbm90IHRydWUh
CiAgICAgICAgRXhwbGFpbiB3aGF0IHRoZSBwcm9ibGVtIGlzLgoKICAgIChjKSBEZWZpbmUgYSAi
ZGlyZWN0IiBub3JtYWxpemF0aW9uIGZ1bmN0aW9uIC0tIGkuZS4sIGEgZnVuY3Rpb24KICAgICAg
ICBbbm9ybWFsaXplXSBmcm9tIGJpbmFyeSBudW1iZXJzIHRvIGJpbmFyeSBudW1iZXJzIHN1Y2gg
dGhhdCwKICAgICAgICBmb3IgYW55IGJpbmFyeSBudW1iZXIgYiwgY29udmVydGluZyB0byBhIG5h
dHVyYWwgYW5kIHRoZW4gYmFjawogICAgICAgIHRvIGJpbmFyeSB5aWVsZHMgWyhub3JtYWxpemUg
YildLiAgUHJvdmUgaXQuICAoV2FybmluZzogVGhpcwogICAgICAgIHBhcnQgaXMgdHJpY2t5ISkK
CiAgICBBZ2FpbiwgZmVlbCBmcmVlIHRvIGNoYW5nZSB5b3VyIGVhcmxpZXIgZGVmaW5pdGlvbnMg
aWYgdGhpcyBoZWxwcwogICAgaGVyZS4gKikKCigqIEZJTEwgSU4gSEVSRSAqKQooKiogW10gKikK
CigqICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
IyMjIyMjIyMjIyMjICopCigqKiAqIEZvcm1hbCB2cy4gSW5mb3JtYWwgUHJvb2YgKE9wdGlvbmFs
KSAqKQoKKCoqICJfSW5mb3JtYWwgcHJvb2ZzIGFyZSBhbGdvcml0aG1zOyBmb3JtYWwgcHJvb2Zz
IGFyZSBjb2RlXy4iICopCgooKiogVGhlIHF1ZXN0aW9uIG9mIHdoYXQgY29uc3RpdHV0ZXMgYSBw
cm9vZiBvZiBhIG1hdGhlbWF0aWNhbAogICAgY2xhaW0gaGFzIGNoYWxsZW5nZWQgcGhpbG9zb3Bo
ZXJzIGZvciBtaWxsZW5uaWEsIGJ1dCBhIHJvdWdoIGFuZAogICAgcmVhZHkgZGVmaW5pdGlvbiBj
b3VsZCBiZSB0aGlzOiBBIHByb29mIG9mIGEgbWF0aGVtYXRpY2FsCiAgICBwcm9wb3NpdGlvbiBb
UF0gaXMgYSB3cml0dGVuIChvciBzcG9rZW4pIHRleHQgdGhhdCBpbnN0aWxscyBpbiB0aGUKICAg
IHJlYWRlciBvciBoZWFyZXIgdGhlIGNlcnRhaW50eSB0aGF0IFtQXSBpcyB0cnVlLiAgVGhhdCBp
cywgYSBwcm9vZgogICAgaXMgYW4gYWN0IG9mIGNvbW11bmljYXRpb24uCgogICAgQWN0cyBvZiBj
b21tdW5pY2F0aW9uIG1heSBpbnZvbHZlIGRpZmZlcmVudCBzb3J0cyBvZiByZWFkZXJzLiAgT24K
ICAgIG9uZSBoYW5kLCB0aGUgInJlYWRlciIgY2FuIGJlIGEgcHJvZ3JhbSBsaWtlIENvcSwgaW4g
d2hpY2ggY2FzZQogICAgdGhlICJiZWxpZWYiIHRoYXQgaXMgaW5zdGlsbGVkIGlzIHRoYXQgW1Bd
IGNhbiBiZSBtZWNoYW5pY2FsbHkKICAgIGRlcml2ZWQgZnJvbSBhIGNlcnRhaW4gc2V0IG9mIGZv
cm1hbCBsb2dpY2FsIHJ1bGVzLCBhbmQgdGhlIHByb29mCiAgICBpcyBhIHJlY2lwZSB0aGF0IGd1
aWRlcyB0aGUgcHJvZ3JhbSBpbiBjaGVja2luZyB0aGlzIGZhY3QuICBTdWNoCiAgICByZWNpcGVz
IGFyZSBfZm9ybWFsXyBwcm9vZnMuCgogICAgQWx0ZXJuYXRpdmVseSwgdGhlIHJlYWRlciBjYW4g
YmUgYSBodW1hbiBiZWluZywgaW4gd2hpY2ggY2FzZSB0aGUKICAgIHByb29mIHdpbGwgYmUgd3Jp
dHRlbiBpbiBFbmdsaXNoIG9yIHNvbWUgb3RoZXIgbmF0dXJhbCBsYW5ndWFnZSwKICAgIGFuZCB3
aWxsIHRodXMgbmVjZXNzYXJpbHkgYmUgX2luZm9ybWFsXy4gIEhlcmUsIHRoZSBjcml0ZXJpYSBm
b3IKICAgIHN1Y2Nlc3MgYXJlIGxlc3MgY2xlYXJseSBzcGVjaWZpZWQuICBBICJ2YWxpZCIgcHJv
b2YgaXMgb25lIHRoYXQKICAgIG1ha2VzIHRoZSByZWFkZXIgYmVsaWV2ZSBbUF0uICBCdXQgdGhl
IHNhbWUgcHJvb2YgbWF5IGJlIHJlYWQgYnkKICAgIG1hbnkgZGlmZmVyZW50IHJlYWRlcnMsIHNv
bWUgb2Ygd2hvbSBtYXkgYmUgY29udmluY2VkIGJ5IGEKICAgIHBhcnRpY3VsYXIgd2F5IG9mIHBo
cmFzaW5nIHRoZSBhcmd1bWVudCwgd2hpbGUgb3RoZXJzIG1heSBub3QgYmUuCiAgICBTb21lIHJl
YWRlcnMgbWF5IGJlIHBhcnRpY3VsYXJseSBwZWRhbnRpYywgaW5leHBlcmllbmNlZCwgb3IganVz
dAogICAgcGxhaW4gdGhpY2staGVhZGVkOyB0aGUgb25seSB3YXkgdG8gY29udmluY2UgdGhlbSB3
aWxsIGJlIHRvIG1ha2UKICAgIHRoZSBhcmd1bWVudCBpbiBwYWluc3Rha2luZyBkZXRhaWwuICBC
dXQgb3RoZXIgcmVhZGVycywgbW9yZQogICAgZmFtaWxpYXIgaW4gdGhlIGFyZWEsIG1heSBmaW5k
IGFsbCB0aGlzIGRldGFpbCBzbyBvdmVyd2hlbG1pbmcKICAgIHRoYXQgdGhleSBsb3NlIHRoZSBv
dmVyYWxsIHRocmVhZDsgYWxsIHRoZXkgd2FudCBpcyB0byBiZSB0b2xkIHRoZQogICAgbWFpbiBp
ZGVhcywgc2luY2UgaXQgaXMgZWFzaWVyIGZvciB0aGVtIHRvIGZpbGwgaW4gdGhlIGRldGFpbHMg
Zm9yCiAgICB0aGVtc2VsdmVzIHRoYW4gdG8gd2FkZSB0aHJvdWdoIGEgd3JpdHRlbiBwcmVzZW50
YXRpb24gb2YgdGhlbS4KICAgIFVsdGltYXRlbHksIHRoZXJlIGlzIG5vIHVuaXZlcnNhbCBzdGFu
ZGFyZCwgYmVjYXVzZSB0aGVyZSBpcyBubwogICAgc2luZ2xlIHdheSBvZiB3cml0aW5nIGFuIGlu
Zm9ybWFsIHByb29mIHRoYXQgaXMgZ3VhcmFudGVlZCB0bwogICAgY29udmluY2UgZXZlcnkgY29u
Y2VpdmFibGUgcmVhZGVyLgoKICAgIEluIHByYWN0aWNlLCBob3dldmVyLCBtYXRoZW1hdGljaWFu
cyBoYXZlIGRldmVsb3BlZCBhIHJpY2ggc2V0IG9mCiAgICBjb252ZW50aW9ucyBhbmQgaWRpb21z
IGZvciB3cml0aW5nIGFib3V0IGNvbXBsZXggbWF0aGVtYXRpY2FsCiAgICBvYmplY3RzIHRoYXQg
LS0gYXQgbGVhc3Qgd2l0aGluIGEgY2VydGFpbiBjb21tdW5pdHkgLS0gbWFrZQogICAgY29tbXVu
aWNhdGlvbiBmYWlybHkgcmVsaWFibGUuICBUaGUgY29udmVudGlvbnMgb2YgdGhpcyBzdHlsaXpl
ZAogICAgZm9ybSBvZiBjb21tdW5pY2F0aW9uIGdpdmUgYSBmYWlybHkgY2xlYXIgc3RhbmRhcmQg
Zm9yIGp1ZGdpbmcKICAgIHByb29mcyBnb29kIG9yIGJhZC4KCiAgICBCZWNhdXNlIHdlIGFyZSB1
c2luZyBDb3EgaW4gdGhpcyBjb3Vyc2UsIHdlIHdpbGwgYmUgd29ya2luZwogICAgaGVhdmlseSB3
aXRoIGZvcm1hbCBwcm9vZnMuICBCdXQgdGhpcyBkb2Vzbid0IG1lYW4gd2UgY2FuCiAgICBjb21w
bGV0ZWx5IGZvcmdldCBhYm91dCBpbmZvcm1hbCBvbmVzISAgRm9ybWFsIHByb29mcyBhcmUgdXNl
ZnVsCiAgICBpbiBtYW55IHdheXMsIGJ1dCB0aGV5IGFyZSBfbm90XyB2ZXJ5IGVmZmljaWVudCB3
YXlzIG9mCiAgICBjb21tdW5pY2F0aW5nIGlkZWFzIGJldHdlZW4gaHVtYW4gYmVpbmdzLiAqKQoK
KCoqIEZvciBleGFtcGxlLCBoZXJlIGlzIGEgcHJvb2YgdGhhdCBhZGRpdGlvbiBpcyBhc3NvY2lh
dGl2ZTogKikKClRoZW9yZW0gcGx1c19hc3NvYycgOiBmb3JhbGwgbiBtIHAgOiBuYXQsCiAgbiAr
IChtICsgcCkgPSAobiArIG0pICsgcC4KUHJvb2YuIGludHJvcyBuIG0gcC4gaW5kdWN0aW9uIG4g
YXMgW3wgbicgSUhuJ10uIHJlZmxleGl2aXR5LgogIHNpbXBsLiByZXdyaXRlIC0+IElIbicuIHJl
ZmxleGl2aXR5LiAgUWVkLgoKKCoqIENvcSBpcyBwZXJmZWN0bHkgaGFwcHkgd2l0aCB0aGlzLiAg
Rm9yIGEgaHVtYW4sIGhvd2V2ZXIsIGl0CiAgICBpcyBkaWZmaWN1bHQgdG8gbWFrZSBtdWNoIHNl
bnNlIG9mIGl0LiAgV2UgY2FuIHVzZSBjb21tZW50cyBhbmQKICAgIGJ1bGxldHMgdG8gc2hvdyB0
aGUgc3RydWN0dXJlIGEgbGl0dGxlIG1vcmUgY2xlYXJseS4uLiAqKQoKVGhlb3JlbSBwbHVzX2Fz
c29jJycgOiBmb3JhbGwgbiBtIHAgOiBuYXQsCiAgbiArIChtICsgcCkgPSAobiArIG0pICsgcC4K
UHJvb2YuCiAgaW50cm9zIG4gbSBwLiBpbmR1Y3Rpb24gbiBhcyBbfCBuJyBJSG4nXS4KICAtICgq
IG4gPSAwICopCiAgICByZWZsZXhpdml0eS4KICAtICgqIG4gPSBTIG4nICopCiAgICBzaW1wbC4g
cmV3cml0ZSAtPiBJSG4nLiByZWZsZXhpdml0eS4gICBRZWQuCgooKiogLi4uIGFuZCBpZiB5b3Un
cmUgdXNlZCB0byBDb3EgeW91IG1heSBiZSBhYmxlIHRvIHN0ZXAKICAgIHRocm91Z2ggdGhlIHRh
Y3RpY3Mgb25lIGFmdGVyIHRoZSBvdGhlciBpbiB5b3VyIG1pbmQgYW5kIGltYWdpbmUKICAgIHRo
ZSBzdGF0ZSBvZiB0aGUgY29udGV4dCBhbmQgZ29hbCBzdGFjayBhdCBlYWNoIHBvaW50LCBidXQg
aWYgdGhlCiAgICBwcm9vZiB3ZXJlIGV2ZW4gYSBsaXR0bGUgYml0IG1vcmUgY29tcGxpY2F0ZWQg
dGhpcyB3b3VsZCBiZSBuZXh0CiAgICB0byBpbXBvc3NpYmxlLgoKICAgIEEgKHBlZGFudGljKSBt
YXRoZW1hdGljaWFuIG1pZ2h0IHdyaXRlIHRoZSBwcm9vZiBzb21ldGhpbmcgbGlrZQogICAgdGhp
czogKikKCigqKiAtIF9UaGVvcmVtXzogRm9yIGFueSBbbl0sIFttXSBhbmQgW3BdLAoKICAgICAg
biArIChtICsgcCkgPSAobiArIG0pICsgcC4KCiAgICBfUHJvb2ZfOiBCeSBpbmR1Y3Rpb24gb24g
W25dLgoKICAgIC0gRmlyc3QsIHN1cHBvc2UgW24gPSAwXS4gIFdlIG11c3Qgc2hvdwoKICAgICAg
ICAwICsgKG0gKyBwKSA9ICgwICsgbSkgKyBwLgoKICAgICAgVGhpcyBmb2xsb3dzIGRpcmVjdGx5
IGZyb20gdGhlIGRlZmluaXRpb24gb2YgWytdLgoKICAgIC0gTmV4dCwgc3VwcG9zZSBbbiA9IFMg
biddLCB3aGVyZQoKICAgICAgICBuJyArIChtICsgcCkgPSAobicgKyBtKSArIHAuCgogICAgICBX
ZSBtdXN0IHNob3cKCiAgICAgICAgKFMgbicpICsgKG0gKyBwKSA9ICgoUyBuJykgKyBtKSArIHAu
CgogICAgICBCeSB0aGUgZGVmaW5pdGlvbiBvZiBbK10sIHRoaXMgZm9sbG93cyBmcm9tCgogICAg
ICAgIFMgKG4nICsgKG0gKyBwKSkgPSBTICgobicgKyBtKSArIHApLAoKICAgICAgd2hpY2ggaXMg
aW1tZWRpYXRlIGZyb20gdGhlIGluZHVjdGlvbiBoeXBvdGhlc2lzLiAgX1FlZF8uICopCgoKKCoq
IFRoZSBvdmVyYWxsIGZvcm0gb2YgdGhlIHByb29mIGlzIGJhc2ljYWxseSBzaW1pbGFyLCBhbmQg
b2YKICAgIGNvdXJzZSB0aGlzIGlzIG5vIGFjY2lkZW50OiBDb3EgaGFzIGJlZW4gZGVzaWduZWQg
c28gdGhhdCBpdHMKICAgIFtpbmR1Y3Rpb25dIHRhY3RpYyBnZW5lcmF0ZXMgdGhlIHNhbWUgc3Vi
LWdvYWxzLCBpbiB0aGUgc2FtZQogICAgb3JkZXIsIGFzIHRoZSBidWxsZXQgcG9pbnRzIHRoYXQg
YSBtYXRoZW1hdGljaWFuIHdvdWxkIHdyaXRlLiAgQnV0CiAgICB0aGVyZSBhcmUgc2lnbmlmaWNh
bnQgZGlmZmVyZW5jZXMgb2YgZGV0YWlsOiB0aGUgZm9ybWFsIHByb29mIGlzCiAgICBtdWNoIG1v
cmUgZXhwbGljaXQgaW4gc29tZSB3YXlzIChlLmcuLCB0aGUgdXNlIG9mIFtyZWZsZXhpdml0eV0p
CiAgICBidXQgbXVjaCBsZXNzIGV4cGxpY2l0IGluIG90aGVycyAoaW4gcGFydGljdWxhciwgdGhl
ICJwcm9vZiBzdGF0ZSIKICAgIGF0IGFueSBnaXZlbiBwb2ludCBpbiB0aGUgQ29xIHByb29mIGlz
IGNvbXBsZXRlbHkgaW1wbGljaXQsCiAgICB3aGVyZWFzIHRoZSBpbmZvcm1hbCBwcm9vZiByZW1p
bmRzIHRoZSByZWFkZXIgc2V2ZXJhbCB0aW1lcyB3aGVyZQogICAgdGhpbmdzIHN0YW5kKS4gKikK
CigqKiAqKioqIEV4ZXJjaXNlOiAyIHN0YXJzLCBhZHZhbmNlZCwgcmVjb21tZW5kZWQgKHBsdXNf
Y29tbV9pbmZvcm1hbCkgICopCigqKiBUcmFuc2xhdGUgeW91ciBzb2x1dGlvbiBmb3IgW3BsdXNf
Y29tbV0gaW50byBhbiBpbmZvcm1hbCBwcm9vZjoKCiAgICBUaGVvcmVtOiBBZGRpdGlvbiBpcyBj
b21tdXRhdGl2ZS4KCiAgICBQcm9vZjogKCogRklMTCBJTiBIRVJFICopCiopCigqKiBbXSAqKQoK
KCoqICoqKiogRXhlcmNpc2U6IDIgc3RhcnMsIG9wdGlvbmFsIChiZXFfbmF0X3JlZmxfaW5mb3Jt
YWwpICAqKQooKiogV3JpdGUgYW4gaW5mb3JtYWwgcHJvb2Ygb2YgdGhlIGZvbGxvd2luZyB0aGVv
cmVtLCB1c2luZyB0aGUKICAgIGluZm9ybWFsIHByb29mIG9mIFtwbHVzX2Fzc29jXSBhcyBhIG1v
ZGVsLiAgRG9uJ3QganVzdAogICAgcGFyYXBocmFzZSB0aGUgQ29xIHRhY3RpY3MgaW50byBFbmds
aXNoIQoKICAgIFRoZW9yZW06IFt0cnVlID0gYmVxX25hdCBuIG5dIGZvciBhbnkgW25dLgoKICAg
IFByb29mOiAoKiBGSUxMIElOIEhFUkUgKikKW10gKikKCigqKiAkRGF0ZTogMjAxNi0wNS0yNiAx
NjoxNzoxOSAtMDQwMCAoVGh1LCAyNiBNYXkgMjAxNikgJCAqKQoK
(*UHIDE*)