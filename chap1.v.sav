Inductive day : Type :=
  | monday : day
  | tuesday : day
  | wednesday : day
  | thursday : day
  | friday : day
  | saturday : day
  | sunday : day.

Definition next_weekday (d:day) : day :=
  match d with
  | monday => tuesday
  | tuesday => wednesday
  | wednesday => thursday
  | thursday => friday
  | friday => monday
  | saturday => monday
  | sunday => monday
  end.

(* Execute code directly with Compute *)
Compute (next_weekday friday).
Compute (next_weekday (next_weekday saturday)).


(* Proof by example of next_weekday? *)
Example test_next_weekday:
  (next_weekday (next_weekday saturday)) = tuesday.
Proof. simpl. reflexivity. Qed.

(* Boolean type and helpers *)

Inductive bool : Type :=
  | true : bool
  | false : bool.

Definition negb (b:bool) : bool :=
  match b with
  | true => false
  | false => true
  end.

Definition andb (b1:bool) (b2:bool) : bool :=
  match b1 with
  | true => b2
  | false => false
  end.

Definition orb (b1:bool) (b2:bool) : bool :=
  match b1 with
  | true => true
  | false => b2
  end.

Compute (orb true false).

Example test_orb1: (orb true false) = true.
Proof. simpl. reflexivity. Qed.
Example test_orb2: (orb false false) = false.
Proof. simpl. reflexivity. Qed.
Example test_orb3: (orb false true) = true.
Proof. simpl. reflexivity. Qed.
Example test_orb4: (orb true true) = true.
Proof. simpl. reflexivity. Qed.

(* Infix operators *)

Infix "&&" := andb.
Infix "||" := orb.

Example test_orb5: false || false || true = true.
Proof. simpl. reflexivity. Qed.

(*HIDE*)CkRlZmluaXRpb24gbmFuZGIgKGIxOmJvb2wpIChiMjpib29sKSA6IGJvb2wgOj0KICBtYXRjaCBi
MSB3aXRoCiAgfCB0cnVlID0+IG5lZ2IgYjIKICB8IGZhbHNlID0+IHRydWUKICBlbmQuCgpFeGFt
cGxlIHRlc3RfbmFuZGIxOiAobmFuZGIgdHJ1ZSBmYWxzZSkgPSB0cnVlLgpQcm9vZi4gc2ltcGwu
IHJlZmxleGl2aXR5LiBRZWQuCkV4YW1wbGUgdGVzdF9uYW5kYjI6IChuYW5kYiBmYWxzZSBmYWxz
ZSkgPSB0cnVlLgpQcm9vZi4gc2ltcGwuIHJlZmxleGl2aXR5LiBRZWQuCkV4YW1wbGUgdGVzdF9u
YW5kYjM6IChuYW5kYiBmYWxzZSB0cnVlKSA9IHRydWUuClByb29mLiBzaW1wbC4gcmVmbGV4aXZp
dHkuIFFlZC4KRXhhbXBsZSB0ZXN0X25hbmRiNDogKG5hbmRiIHRydWUgdHJ1ZSkgPSBmYWxzZS4K
UHJvb2YuIHNpbXBsLiByZWZsZXhpdml0eS4gUWVkLgoKCkRlZmluaXRpb24gYW5kYjMgKGIxOmJv
b2wpIChiMjpib29sKSAoYjM6Ym9vbCkgOiBib29sIDo9CiBiMSAmJiBiMiAmJiBiMy4KCkV4YW1w
bGUgdGVzdF9hbmRiMzE6IChhbmRiMyB0cnVlIHRydWUgdHJ1ZSkgPSB0cnVlLgpQcm9vZi4gc2lt
cGwuIHJlZmxleGl2aXR5LiBRZWQuCkV4YW1wbGUgdGVzdF9hbmRiMzI6IChhbmRiMyBmYWxzZSB0
cnVlIHRydWUpID0gZmFsc2UuClByb29mLiBzaW1wbC4gcmVmbGV4aXZpdHkuIFFlZC4KRXhhbXBs
ZSB0ZXN0X2FuZGIzMzogKGFuZGIzIHRydWUgZmFsc2UgdHJ1ZSkgPSBmYWxzZS4KUHJvb2YuIHNp
bXBsLiByZWZsZXhpdml0eS4gUWVkLgpFeGFtcGxlIHRlc3RfYW5kYjM0OiAoYW5kYjMgdHJ1ZSB0
cnVlIGZhbHNlKSA9IGZhbHNlLgpQcm9vZi4gc2ltcGwuIHJlZmxleGl2aXR5LiBRZWQuCgo=
(*UHIDE*)

Check true.
(* ===> true : bool *)

Check (negb true).
(* ===> negb true : bool *)

Check negb.
(* ===> negb : bool -> bool *)

Module Playground1.

Inductive nat : Type :=
  | O : nat
  | S : nat -> nat.

Definition pred (n : nat) : nat :=
  match n with
    | O => O
    | S n' => n'
  end.

End Playground1.

Definition minustwo (n : nat) : nat :=
  match n with
    | O => O
    | S O => O
    | S (S n') => n'
  end.

(* Somehow Coq is able to convert these recursive numbers ...
   into numbers...?! Wat. *)
Check (S (S (S (S O)))).
  (* ===> 4 : nat *)
Compute (minustwo 4).
  (* ===> 2 : nat *)

(* Fixpoint = recursive function *)
Fixpoint evenb (n:nat) : bool :=
  match n with
  | O => true
  | S O => false
  | S (S n') => evenb n'
  end.

Definition oddb (n:nat) : bool := negb (evenb n).

Example test_oddb1: oddb 1 = true.
Proof. simpl. reflexivity. Qed.
Example test_oddb2: oddb 4 = false.
Proof. simpl. reflexivity. Qed.

Module Playground2.

Fixpoint plus (n : nat) (m : nat) : nat :=
  match n with
    | O => m
    | S n' => S (plus n' m)
  end.

(*
  addition via recursion
  plus (S (S (S O))) (S (S O))
==> S (plus (S (S O)) (S (S O)))
      by the second clause of the match
==> S (S (plus (S O) (S (S O))))
      by the second clause of the match
==> S (S (S (plus O (S (S O)))))
      by the second clause of the match
==> S (S (S (S (S O))))
      by the first clause of the match
This is blowing my mind...
 *)
Compute (plus 3 2).

(* same syntax as two parens, still curriable *)
Fixpoint mult (n m : nat) : nat :=
  match n with
    | O => O
    | S n' => plus m (mult n' m)
  end.

Check mult.
(* mult : nat -> nat -> nat *)

Example test_mult1: (mult 3 3) = 9.
Proof. simpl. reflexivity. Qed.

(* _ is wildcard, as expected  *)

(* obviously, our nat can't go negative... how could we prove this though? *)
Fixpoint minus (n m:nat) : nat :=
  match n, m with
  | O , _ => O
  | S _ , O => n
  | S n', S m' => minus n' m'
  end.

End Playground2.

Fixpoint exp (base power : nat) : nat :=
  match power with
  | O => S O
  | S p => mult base (exp base p)
  end.

Definition minusone (n : nat) : nat :=
  match n with
    | O => O
    | S O => O
    | S n' => n'
  end.

Example test_minusone: (minusone 3) = 2.
Proof. simpl. reflexivity. Qed.


(*HIDE*)CgooKiBmYWN0b3JpYWwoMCkgID0gIDEKICAgZmFjdG9yaWFsKG4pICA9ICBuICogZmFjdG9yaWFs
KG4tMSkgICAgIChpZiBuPjApICopCkZpeHBvaW50IGZhY3RvcmlhbCAobjpuYXQpIDogbmF0IDo9
CiAgbWF0Y2ggbiB3aXRoCiAgfCBPID0+IFMgTwogIHwgbiA9PiBtdWx0IG4gKGZhY3RvcmlhbCAo
bWludXMgbiAoUyBPKSkpCiAgZW5kLgoKICAKCkV4YW1wbGUgdGVzdF9mYWN0b3JpYWwxOiAoZmFj
dG9yaWFsIDMpID0gNi4KUHJvb2YuIHNpbXBsLiByZWZsZXhpdml0eS4gUWVkLgpFeGFtcGxlIHRl
c3RfZmFjdG9yaWFsMzogKGZhY3RvcmlhbCAwKSA9IDEuClByb29mLiBzaW1wbC4gcmVmbGV4aXZp
dHkuIFFlZC4KRXhhbXBsZSB0ZXN0X2ZhY3RvcmlhbDI6IChmYWN0b3JpYWwgNSkgPSAobXVsdCAx
MCAxMikuClByb29mLiBzaW1wbC4gcmVmbGV4aXZpdHkuIFFlZC4KCgo=
(*UHIDE*)
