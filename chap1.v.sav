Inductive day : Type :=
  | monday : day
  | tuesday : day
  | wednesday : day
  | thursday : day
  | friday : day
  | saturday : day
  | sunday : day.

Definition next_weekday (d:day) : day :=
  match d with
  | monday => tuesday
  | tuesday => wednesday
  | wednesday => thursday
  | thursday => friday
  | friday => monday
  | saturday => monday
  | sunday => monday
  end.

(* Execute code directly with Compute *)
Compute (next_weekday friday).
Compute (next_weekday (next_weekday saturday)).


(* Proof by example of next_weekday? *)
Example test_next_weekday:
  (next_weekday (next_weekday saturday)) = tuesday.
Proof. simpl. reflexivity. Qed.

(* Boolean type and helpers *)

Inductive bool : Type :=
  | true : bool
  | false : bool.

Definition negb (b:bool) : bool :=
  match b with
  | true => false
  | false => true
  end.

Definition andb (b1:bool) (b2:bool) : bool :=
  match b1 with
  | true => b2
  | false => false
  end.

Definition orb (b1:bool) (b2:bool) : bool :=
  match b1 with
  | true => true
  | false => b2
  end.

Compute (orb true false).

Example test_orb1: (orb true false) = true.
Proof. simpl. reflexivity. Qed.
Example test_orb2: (orb false false) = false.
Proof. simpl. reflexivity. Qed.
Example test_orb3: (orb false true) = true.
Proof. simpl. reflexivity. Qed.
Example test_orb4: (orb true true) = true.
Proof. simpl. reflexivity. Qed.

(* Infix operators *)

Infix "&&" := andb.
Infix "||" := orb.

Example test_orb5: false || false || true = true.
Proof. simpl. reflexivity. Qed.

(*HIDE*)CkRlZmluaXRpb24gbmFuZGIgKGIxOmJvb2wpIChiMjpib29sKSA6IGJvb2wgOj0KICBtYXRjaCBi
MSB3aXRoCiAgfCB0cnVlID0+IG5lZ2IgYjIKICB8IGZhbHNlID0+IHRydWUKICBlbmQuCgpFeGFt
cGxlIHRlc3RfbmFuZGIxOiAobmFuZGIgdHJ1ZSBmYWxzZSkgPSB0cnVlLgpQcm9vZi4gc2ltcGwu
IHJlZmxleGl2aXR5LiBRZWQuCkV4YW1wbGUgdGVzdF9uYW5kYjI6IChuYW5kYiBmYWxzZSBmYWxz
ZSkgPSB0cnVlLgpQcm9vZi4gc2ltcGwuIHJlZmxleGl2aXR5LiBRZWQuCkV4YW1wbGUgdGVzdF9u
YW5kYjM6IChuYW5kYiBmYWxzZSB0cnVlKSA9IHRydWUuClByb29mLiBzaW1wbC4gcmVmbGV4aXZp
dHkuIFFlZC4KRXhhbXBsZSB0ZXN0X25hbmRiNDogKG5hbmRiIHRydWUgdHJ1ZSkgPSBmYWxzZS4K
UHJvb2YuIHNpbXBsLiByZWZsZXhpdml0eS4gUWVkLgoKCkRlZmluaXRpb24gYW5kYjMgKGIxOmJv
b2wpIChiMjpib29sKSAoYjM6Ym9vbCkgOiBib29sIDo9CiBiMSAmJiBiMiAmJiBiMy4KCkV4YW1w
bGUgdGVzdF9hbmRiMzE6IChhbmRiMyB0cnVlIHRydWUgdHJ1ZSkgPSB0cnVlLgpQcm9vZi4gc2lt
cGwuIHJlZmxleGl2aXR5LiBRZWQuCkV4YW1wbGUgdGVzdF9hbmRiMzI6IChhbmRiMyBmYWxzZSB0
cnVlIHRydWUpID0gZmFsc2UuClByb29mLiBzaW1wbC4gcmVmbGV4aXZpdHkuIFFlZC4KRXhhbXBs
ZSB0ZXN0X2FuZGIzMzogKGFuZGIzIHRydWUgZmFsc2UgdHJ1ZSkgPSBmYWxzZS4KUHJvb2YuIHNp
bXBsLiByZWZsZXhpdml0eS4gUWVkLgpFeGFtcGxlIHRlc3RfYW5kYjM0OiAoYW5kYjMgdHJ1ZSB0
cnVlIGZhbHNlKSA9IGZhbHNlLgpQcm9vZi4gc2ltcGwuIHJlZmxleGl2aXR5LiBRZWQuCgo=
(*UHIDE*)

Check true.
(* ===> true : bool *)

Check (negb true).
(* ===> negb true : bool *)

Check negb.
(* ===> negb : bool -> bool *)

Module Playground1.

Inductive nat : Type :=
  | O : nat
  | S : nat -> nat.

Definition pred (n : nat) : nat :=
  match n with
    | O => O
    | S n' => n'
  end.

End Playground1.

Definition minustwo (n : nat) : nat :=
  match n with
    | O => O
    | S O => O
    | S (S n') => n'
  end.

(* Somehow Coq is able to convert these recursive numbers ...
   into numbers...?! Wat. *)
Check (S (S (S (S O)))).
  (* ===> 4 : nat *)
Compute (minustwo 4).
  (* ===> 2 : nat *)

(* Fixpoint = recursive function *)
Fixpoint evenb (n:nat) : bool :=
  match n with
  | O => true
  | S O => false
  | S (S n') => evenb n'
  end.

Definition oddb (n:nat) : bool := negb (evenb n).

Example test_oddb1: oddb 1 = true.
Proof. simpl. reflexivity. Qed.
Example test_oddb2: oddb 4 = false.
Proof. simpl. reflexivity. Qed.

Module Playground2.

Fixpoint plus (n : nat) (m : nat) : nat :=
  match n with
    | O => m
    | S n' => S (plus n' m)
  end.

(*
  addition via recursion
  plus (S (S (S O))) (S (S O))
==> S (plus (S (S O)) (S (S O)))
      by the second clause of the match
==> S (S (plus (S O) (S (S O))))
      by the second clause of the match
==> S (S (S (plus O (S (S O)))))
      by the second clause of the match
==> S (S (S (S (S O))))
      by the first clause of the match
This is blowing my mind...
 *)
Compute (plus 3 2).

(* same syntax as two parens, still curriable *)
Fixpoint mult (n m : nat) : nat :=
  match n with
    | O => O
    | S n' => plus m (mult n' m)
  end.

Check mult.
(* mult : nat -> nat -> nat *)

Example test_mult1: (mult 3 3) = 9.
Proof. simpl. reflexivity. Qed.

(* _ is wildcard, as expected  *)

(* obviously, our nat can't go negative... how could we prove this though? *)
Fixpoint minus (n m:nat) : nat :=
  match n, m with
  | O , _ => O
  | S _ , O => n
  | S n', S m' => minus n' m'
  end.

End Playground2.

Fixpoint exp (base power : nat) : nat :=
  match power with
  | O => S O
  | S p => mult base (exp base p)
  end.

Definition minusone (n : nat) : nat :=
  match n with
    | O => O
    | S O => O
    | S n' => n'
  end.

Example test_minusone: (minusone 3) = 2.
Proof. simpl. reflexivity. Qed.

(*HIDE*)CgooKiBmYWN0b3JpYWwoMCkgID0gIDEKICAgZmFjdG9yaWFsKG4pICA9ICBuICogZmFjdG9yaWFs
KG4tMSkgICAgIChpZiBuPjApICopCkZpeHBvaW50IGZhY3RvcmlhbCAobjpuYXQpIDogbmF0IDo9
CiAgbWF0Y2ggbiB3aXRoCiAgfCBPID0+IFMgTwogIHwgUyBuJyA9PiBtdWx0IG4gKGZhY3Rvcmlh
bCBuJykKICBlbmQuCgooKgpkb2VzbnQgd29yayBmb3Igc29tZSByZWFzb24uLi4KRml4cG9pbnQg
ZmFjdG9yaWFsIChuOm5hdCkgOiBuYXQgOj0KICBtYXRjaCBuIHdpdGgKICB8IE8gPT4gUyBPCiAg
fCBfID0+IG11bHQgbiAoZmFjdG9yaWFsIChtaW51c29uZSBuKSkKICB8IFMgbicgPT4gbXVsdCBu
IChmYWN0b3JpYWwgKG1pbnVzb25lIChTIG4nKSkpCiAgZW5kLgoKICopCgpFeGFtcGxlIHRlc3Rf
ZmFjdG9yaWFsMTogKGZhY3RvcmlhbCAzKSA9IDYuClByb29mLiBzaW1wbC4gcmVmbGV4aXZpdHku
IFFlZC4KRXhhbXBsZSB0ZXN0X2ZhY3RvcmlhbDM6IChmYWN0b3JpYWwgMCkgPSAxLgpQcm9vZi4g
c2ltcGwuIHJlZmxleGl2aXR5LiBRZWQuCkV4YW1wbGUgdGVzdF9mYWN0b3JpYWwyOiAoZmFjdG9y
aWFsIDUpID0gKG11bHQgMTAgMTIpLgpQcm9vZi4gc2ltcGwuIHJlZmxleGl2aXR5LiBRZWQuCgo=
(*UHIDE*)

Notation "x + y" := (plus x y)
                       (at level 50, left associativity)
                       : nat_scope.
Notation "x - y" := (minus x y)
                       (at level 50, left associativity)
                       : nat_scope.
Notation "x * y" := (mult x y)
                       (at level 40, left associativity)
                       : nat_scope.

Check ((0 + 1) + 1).

Fixpoint beq_nat (n m : nat) : bool :=
  match n with
  | O => match m with
        | O => true
        | S m' => false
         end
  | S n' => match m with
           | O => false
           | S m' => beq_nat n' m'
            end
  end.

Fixpoint leb (n m : nat) : bool :=
  match n with
  | O => true
  | S n' =>
      match m with
      | O => false
      | S m' => leb n' m'
      end
  end.

Example test_leb1: (leb 2 2) = true.
Proof. simpl. reflexivity. Qed.
Example test_leb2: (leb 2 4) = true.
Proof. simpl. reflexivity. Qed.
Example test_leb3: (leb 4 2) = false.
Proof. simpl. reflexivity. Qed.

(*HIDE*)CkRlZmluaXRpb24gYmx0X25hdCAobiBtIDogbmF0KSA6IGJvb2wgOj0gbGViIChTIG4pIG0uCiAK
RXhhbXBsZSB0ZXN0X2JsdF9uYXQxOiAoYmx0X25hdCAyIDIpID0gZmFsc2UuClByb29mLiBzaW1w
bC4gcmVmbGV4aXZpdHkuIFFlZC4KRXhhbXBsZSB0ZXN0X2JsdF9uYXQyOiAoYmx0X25hdCAyIDQp
ID0gdHJ1ZS4KUHJvb2YuIHNpbXBsLiByZWZsZXhpdml0eS4gUWVkLgpFeGFtcGxlIHRlc3RfYmx0
X25hdDM6IChibHRfbmF0IDQgMikgPSBmYWxzZS4KUHJvb2YuIHNpbXBsLiByZWZsZXhpdml0eS4g
UWVkLgoKQ29tcHV0ZSAoYmx0X25hdCA0IDMpLgoK
(*UHIDE*)

(* we can cause a proof of all natural numbers n with the forall *)
 
Theorem plus_O_n : forall n : nat, 0 + n = n.
Proof.
  intros n. simpl. reflexivity.  Qed.

(* simpl. is not needed, because reflexivity also simplifies  *)

Theorem plus_O_n' : forall n : nat, 0 + n = n.
Proof.
  intros n. reflexivity. Qed.

(* simpl. intros. reflexivity are all tactics used to guide the proof *)

Theorem plus_1_l : forall n:nat, 1 + n = S n.
Proof.
  intros n. reflexivity.  Qed.

Theorem mult_0_l : forall n:nat, 0 * n = 0.
Proof.
  intros n. simpl. reflexivity.  Qed.

(* it looks like both simpl and reflexivity do not simplify terms on the right... *)

Theorem plus_id_example : forall n m:nat,
  n = m ->
  n + n = m + m.
Proof.
  (* move both quantifiers into the context: *)
  intros n m.  
  (* move the hypothesis into the context: *)
  intros H. 
  (* rewrite the goal using the hypothesis: *)
  rewrite -> H. 
  reflexivity.  Qed.

(*HIDE*)CgpUaGVvcmVtIHBsdXNfaWRfZXhlcmNpc2UgOiBmb3JhbGwgbiBtIG8gOiBuYXQsCiAgICBuID0g
bSAtPgogICAgbSA9IG8gLT4KICAgIG4gKyBtID0gbSArIG8uClByb29mLgogICgqIG1vdmUgYm90
aCBxdWFudGlmaWVycyBpbnRvIHRoZSBjb250ZXh0OiAqKQogIGludHJvcyBuIG0gby4gCiAgKCog
bW92ZSBCT1RIIGh5cG90aGVzaXMgaW50byB0aGUgY29udGV4dDogKikKICBpbnRyb3MgSDEgSDIu
IAogICAgICAgICgqIEgxIDogbiA9IG0gKikKICAgICAgICAoKiBIMiA6IG0gPSBvICopCiAgICAg
ICAgKCogIG4gKyBtID0gbSArIG8gKikKICAoKiByZXdyaXRlIHRoZSBnb2FsIHVzaW5nIHRoZSBo
eXBvdGhlc2lzOiAqKQogIHJld3JpdGUgLT4gSDEuICAKICAgICAgICAoKiBtICsgbSA9IG0gKyBv
ICopCiAgcmV3cml0ZSAtPiBIMi4gIAogICAgICAgICgqIG8gKyBvID0gbyArIG8gKikKICByZWZs
ZXhpdml0eS4gIFFlZC4KCigqIEFwcGFyZW50bHkgZWFjaCBoeXBvdGhlc2lzIG5lZWRzIGFuIGlu
dHJvcywgYWxzbyB3ZSBjYW4gcmV3cml0ZSBlYWNoIGh5cG90aGVzaXMgYWNjb3JkaW5nbHkgICop
Cg==
(*UHIDE*)